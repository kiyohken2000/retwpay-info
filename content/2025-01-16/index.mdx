---
title: useEffectã§ã‚ã‚ŠãŒã¡ãªãƒŸã‚¹ã¨å›é¿ç­–
tags: [    ]
date: 2025-01-16
path: blog/2025-01-16
cover: ./img.png
excerpt: Avoiding unnecessary re-renders in React.
keywords:
  - é–‹ç™º
  - ã‚³ãƒ¼ãƒ‰
  - code
  - react native
  - expo
---
import { Link } from 'gatsby';

## ä¾‹1

**ãƒ€ãƒ¡ãªä¾‹**

```javascript
// ğŸ”´ Can we guarantee the last request will set the response?
function RaceConditionExample() {
  const [counter, setCounter] = useState(0);
  const [response, setResponse] = useState(0);
  const [isLoading, setIsLoading] = useState(false);

  useEffect(() => {
    const request = async (requestId) => {
      setIsLoading(true);
      await sleep(Math.random() * 3000);
      setResponse(requestId);
      setIsLoading(false);
    };
    request(counter);
  }, [counter]);

  const handleClick = () => {
    setCounter((prev) => ++prev);
  };

  return <>//....
      <button onClick={handleClick}>Increment</button> //...
    </>;
}
```


**è‰¯ã„ä¾‹**

```javascript
// âœ… Handling the racing condition by clean-up function
useEffect(() => {
  let ignore = false;
  const request = async (requestId) => {
    setIsLoading(true);
    await sleep(Math.random() * 3000);
    if (!ignore) {
      setResponse(requestId);
      setIsLoading(false);
    }
  };
  request(counter);

  return () => {
    ignore = true;
  };
}, [counter]);
```

## ä¾‹2

**ãƒ€ãƒ¡ãªä¾‹**

```javascript
function Parent() {
  const [someState, setSomeState] = useState();
  return <Child onChange={(...) => setSomeState(...)} />
}

function Child({ onChange }) {
  const [isOn, setIsOn] = useState(false);

  useEffect(() => {
    // ğŸš¨ Will trigger an extra render
    onChange(isOn);
  }, [isOn, onChange]);

  function handleClick() {
    // Will trigger the first render after clicking
    setIsOn(!isOn);
  }

  return <button onClick={handleClick}>Toggle</button>;
}
```

**è‰¯ã„ä¾‹**

```javascript
function Parent() {
  const [someState, setSomeState] = useState();
  return <Child onChange={(...) => setSomeState(...)} />
}

function Child({ onChange }) {
  const [isOn, setIsOn] = useState(false);

  // âœ… Good: Perform all updates during the event that caused them
  function handleClick() {
    const newValue = !isOn;
    setIsOn(newValue);
    onChange(newValue);
  }

  return <button onClick={handleClick}>Toggle</button>;
}
```

## ä¾‹3

**ãƒ€ãƒ¡ãªä¾‹**

```javascript
function Parent() {
  const [data, setData] = useState(null);
  
  return <Child onFetched={setData} />;
}

// ğŸ”´ Avoid: Passing data to the parent in an Effect
function Child({ onFetched }) {
  const data = useFetchData();

  useEffect(() => {
    if (data) {
      // ğŸ‡®ğŸ‡¹ Making spaghetti? 
      onFetched(data);
    }
  }, [onFetched, data]);

  return <>{JSON.stringify(data)}</>;
}
```

**è‰¯ã„ä¾‹1**

```javascript
// Suggetion #1 - pass fetch logic to higer component
function Parent() {
  const data = useFetchData();

  // âœ… Good: Passing data down to the child
  return <Child data={data} />;
}

function Child({ data }) {
  return <>{JSON.stringify(data)}</>;
}
```

**è‰¯ã„ä¾‹2**

```javascript
// Suggetion #2 - pass onSuccess/onError handlers to the children component
function Parent() {
  function handleSuccess = (data) => { 
      // some logic
  }
  function handleError = (error) => { 
      // some logic
      toast(error.messasge)
  }
  // âœ… Good: Passing data down to the child
  return <Child onSuccess={handleSuccess} onError={handleError} />;
}

function Child({ onSuccess, onError }) {
  // âœ… Good:The hook invoke the handler on done, no other effects involved
  const mutate = useMutateData({ onSuccess, onError }); 

  return ...;
}
```

---